<html>
  <head>
    <title>Box2dWeb 3Dsimulation Demo</title>
    <style type="text/css">
      .jianju
      {
        text-align:left;
        text-justify: auto;
      }
      body
      {
        font-size:70%;
        font-family:verdana,helvetica,arial,sans-serif;
      }
    </style>
  </head>
  <body onload="init();" onmousemove="getCoordinates(event)" onmouseout="clearCoordinates(event)">
    <canvas id="canvas" width="1200" height="500" style="background-color:#333333;" ></canvas>
    <!-- <div id="cc" style="position:absolute; right:0; top:100px; width:500px; height:50px; margin:0;"></div> -->
    <div id="main" style="width: 1200px; height: 500px;"></div>
    <div id="xycoordinates" style="position:relative; float:left; width:199px; height: 99px; border: 1px; text-align: left;"></div>
    <div id="fieldStrength" style="position:relative; float:left; width:160px; height: 20px; border: 1px; text-align: left; background-color: rgb(238, 154, 106);"></div>
    <div id="main" style="width: 100%; height: 400px;"></div>
    <p class="jianju">打开网页后任意位置，弹出屏幕坐标X和Y</p>
  </body>
  <script type="text/javascript">
    function getCoordinates(event) {
      x = event.screenX / 30;
      y = event.screenY / 30;
      x = x.toFixed(2);
      y = y.toFixed(2);
      document.getElementById("xycoordinates").innerHTML="box2d坐标: (" + x + "," + y + ")";
    }
  </script>
  <script type="text/javascript">
    function clearCoordinates(event) {
      document.getElementById("xycoordinates").innerHTML="";
    }
  </script>
  <script type="text/javascript" src="Box2d.min.js"></script>
  <script type="text/javascript" src="whcoord.js"></script>
  <script type="text/javascript" src="list.js"></script>
  <script type="text/javascript" src="mapl.js"></script>
  <script type="text/javascript" src="grid.js"></script>
  <script type="text/javascript" src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
  <script src="https://cdn.bootcss.com/echarts/4.7.0/echarts.js"></script>
  <script type="text/javascript">
    function init() {
      var gridFieldLength = new GridFieldStrength();
      var b2Vec2 = Box2D.Common.Math.b2Vec2
        , b2Vec3 = Box2D.Common.Math.b2Vec3
        , b2BodyDef = Box2D.Dynamics.b2BodyDef
        , b2Body = Box2D.Dynamics.b2Body
        , b2FixtureDef = Box2D.Dynamics.b2FixtureDef
        , b2World = Box2D.Dynamics.b2World
        , b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
        , b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
        , b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape    
        , b2ContactFilter = Box2D.Dynamics.b2ContactFilter
        , b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef
        , b2DebugDraw = Box2D.Dynamics.b2DebugDraw
        , b2Fixture = Box2D.Dynamics.b2Fixture
        , b2AABB = Box2D.Collision.b2AABB
        , b2WorldManifold = Box2D.Collision.b2WorldManifold
        , b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint
        , b2RayCastInput = Box2D.Collision.b2RayCastInput
        , b2RayCastOutput = Box2D.Collision.b2RayCastOutput
        , b2Color = Box2D.Common.b2Color;

      var po1 = new b2Vec2(18, 8);
      var po2 = new b2Vec2(19, 10.74);
      console.log(rayPathRecognition.DDA_Mutation(po1, po2));
        
      var world = new b2World(new b2Vec2(0,10), true);
      
      var canvas = $('#canvas');
      var context = canvas.get(0).getContext('2d');
      

      // fixture definition
      var fixDef = new b2FixtureDef;
      fixDef.filter.categoryBits = 2;
      fixDef.filter.maskBits = 13;
      fixDef.density = 1.0;     // 密度
      fixDef.friction = 0.5;    // 摩擦
      fixDef.restitution = 0.2; // 弹性

      // body definition
      var bodyDef = new b2BodyDef;

      //create ground
      // bodyDef.type = b2Body.b2_staticBody;
      // bodyDef.position.x = 15;
      // bodyDef.position.y = 16;
      // bodyDef.userData = 'ground';
      // fixDef.shape = new b2PolygonShape;
      // fixDef.shape.SetAsBox(15, 0.5);
      // world.CreateBody(bodyDef).CreateFixture(fixDef);

      // bodyDef.type = b2Body.b2_kinematicBody;
      // bodyDef.position.Set(6,3);s
      // 3.000692, 0.289297    3.000692, 0.293138    3.012279, 0.298885
      // fixDef.shape = new b2PolygonShape;
      // bodyDef.position.Set(0,0);
      // 绘制多边形，但此法存在缺陷，最多绘制八边形
      // fixDef.shape.SetAsArray([
      //   new b2Vec2(5, 8),
      //   new b2Vec2(4, 10),
      //   new b2Vec2(7,7),
      //   new b2Vec2(3,6)],4);
      // bodyDef2.type = b2Body.b2_dynamicBody;
      // bodyDef.position.Set(6,3);
      // fixDef.shape = new b2PolygonShape;
      // fixDef.shape.SetAsBox(8, 1);
      // bodyDef.userData = 'house';
      // world.CreateBody(bodyDef).CreateFixture(fixDef);

      // for(var i = 0; i < 10; ++i) {
      //   // if(Math.random() > 0.5) {
      //   //     fixDef.shape = new b2PolygonShape;//SetArrayList
      //   //     fixDef.shape.SetAsBox( 
      //   //         Math.random() + 0.1 //half width
      //   //       , Math.random() + 0.1 //half height
      //   //     );
      //   // } else {
      //   //     fixDef.shape = new b2CircleShape(
      //   //       Math.random() + 0.1 //radius
      //   //     );
      //   // }
      //   fixDef.shape = new b2PolygonShape;
      //   fixDef.shape.SetAsBox(
      //        Math.random() + 0.1 //half width
      //      , Math.random() + 0.1 //half height
      //    );
      //   bodyDef.position.x = Math.random(0,4) * 10;
      //   bodyDef.position.y = Math.random(0,2) * 10;
      //   bodyDef.userData = 'house';
      //   world.CreateBody(bodyDef).CreateFixture(fixDef);
      // }

      bodyDef.type = b2Body.b2_staticBody;
      // bodyDef.type = b2Body.b2_dynamicBody;
      
      fixDef.shape = new b2PolygonShape;
      fixDef.shape.SetAsBox(1,0.5);

      bodyDef.position.Set(28,3);
      world.CreateBody(bodyDef).CreateFixture(fixDef);

      bodyDef.position.Set(20,11);
      world.CreateBody(bodyDef).CreateFixture(fixDef);

      bodyDef.position.Set(30,14);
      world.CreateBody(bodyDef).CreateFixture(fixDef);

      bodyDef.position.Set(6,6);
      world.CreateBody(bodyDef).CreateFixture(fixDef);

      bodyDef.position.Set(10,5);
      world.CreateBody(bodyDef).CreateFixture(fixDef);
      
      bodyDef.position.Set(8,10);
      world.CreateBody(bodyDef).CreateFixture(fixDef);

      bodyDef.position.Set(4,2);
      world.CreateBody(bodyDef).CreateFixture(fixDef);

      bodyDef.position.Set(0,8);
      world.CreateBody(bodyDef).CreateFixture(fixDef);

      bodyDef.position.Set(23,5);
      // bodyDef.type = b2Body.b2_kinematicBody;
      fixDef.shape = new b2CircleShape(2);
      world.CreateBody(bodyDef).CreateFixture(fixDef);


      //box

      // var bodyDef = new b2BodyDef;
      // // bodyDef.type = b2Body.b2_dynamicBody;
      // bodyDef.type = b2Body.b2_staticBody;
      // bodyDef.position.Set(9,7);
      // bodyDef.userData = 'box';

      // var fixDef = new b2FixtureDef;
      // fixDef.filter.categoryBits = 1;
      // fixDef.density = 10.0;
      // fixDef.friction = 0.5;
      // fixDef.restitution = .5;

      // fixDef.shape = new b2PolygonShape;
      // fixDef.shape.SetAsBox(1,5);

      // world.CreateBody(bodyDef).CreateFixture(fixDef);

      //circle

      // var bodyDef2 = new b2BodyDef;
      // bodyDef2.type = b2Body.b2_dynamicBody;
      // bodyDef2.position.Set(4,8);
      // bodyDef2.userData = 'obj';

      // var fixDef2 = new b2FixtureDef;
      // fixDef2.filter.categoryBits = 2;
      // fixDef2.filter.maskBits = 13;
      // fixDef2.density = 10.0;
      // fixDef2.friction = 0.5;
      // fixDef2.restitution = .2; 
      // fixDef2.shape = new b2CircleShape(1);
      // // circlesensor
      // var cc = new b2FixtureDef;
      // cc.shape = new b2CircleShape(2);
      // cc.shape.SetLocalPosition(new b2Vec2(0 ,0));
      // cc.density = 0;
      // cc.isSensor = true;
      // cc.filter.categoryBits = 8;

      // world.CreateBody(bodyDef2).CreateFixture(fixDef2);
      // world.CreateBody(bodyDef2).CreateFixture(cc);

      // //
      // var holderDef = new b2BodyDef;
      // holderDef.type = b2Body.b2_staticBody;
      // holderDef.userData = "ground";
      // holderDef.position.Set(10, 14);

      // world.CreateBody(holderDef).CreateFixture(floorFixture);

      // add four walls to the static body
      bodyDef.type = b2Body.b2_staticBody;

      var bl = new b2Vec2(0,0);
      var br = new b2Vec2(38,0);
      var tl = new b2Vec2(0,16);
      var tr = new b2Vec2(38,16);

      // 上边界
      bodyDef.position.Set(0,0);
      fixDef.shape = new b2PolygonShape;
      fixDef.shape.SetAsEdge(bl,br);
      world.CreateBody(bodyDef).CreateFixture(fixDef);

      // 下边界
      bodyDef.position.Set(0,0);   
      fixDef.shape = new b2PolygonShape;
      fixDef.shape.SetAsEdge(tl,tr);
      world.CreateBody(bodyDef).CreateFixture(fixDef);

      // 左边界
      bodyDef.position.Set(0,0);   
      fixDef.shape = new b2PolygonShape;
      fixDef.shape.SetAsEdge(bl,tl);
      world.CreateBody(bodyDef).CreateFixture(fixDef);

      // 右边界
      bodyDef.position.Set(0,0);   
      fixDef.shape = new b2PolygonShape;
      fixDef.shape.SetAsEdge(br,tr);
      world.CreateBody(bodyDef).CreateFixture(fixDef);


      var c=0;
      $(window).keydown(function(e) {
          $('#aa').html(++c);
          code = e.keyCode;
          if(c==1)   {
          if(code == 38 && onground)
              wheel.SetLinearVelocity(new b2Vec2(0,-10));
          if(code == 39)
            wheel.ApplyForce(new b2Vec2(1000,0), box1.GetWorldPoint(new b2Vec2(0,0)));
          if(code == 37)
            wheel.ApplyForce(new b2Vec2(-1000,0), box1.GetWorldPoint(new b2Vec2(0,0)));
          }
      });
      $(window).keyup(function(e) {
        c=0;
      });

      // Box2D EventListener

      var listener = new Box2D.Dynamics.b2ContactListener;
      listener.BeginContact = function(contact) {
          if(contact.GetFixtureA().GetBody().GetUserData()== 'house' || contact.GetFixtureB().GetBody().GetUserData()== 'obj' ) // think about why we don't use fixture's userData directly.
            onground = true;// don't put 'var' here!
          fxA=contact.GetFixtureA();
          fxB=contact.GetFixtureB();
          sA=fxA.IsSensor();
          sB=fxB.IsSensor();
          if((sA && !sB) || (sB && !sA)) {
              if(sA) {
                  $('#cc').prepend(contact.GetFixtureB().GetBody().GetUserData() + ' is in the viscinity of body '+contact.GetFixtureA().GetBody().GetUserData()+'<br>');
              }
              else   {
                  $('#cc').prepend(contact.GetFixtureA().GetBody().GetUserData() + ' is in the viscinity of body '+contact.GetFixtureB().GetBody().GetUserData()+'<br>');
              }
          }
      }       
      listener.EndContact = function(contact) {
      if (contact.GetFixtureA().GetBody().GetUserData()== 'house' || contact.GetFixtureB().GetBody().GetUserData()== 'obj' )
          onground = false;
      }   


      var debugDraw = new b2DebugDraw();
      debugDraw.SetSprite ( document.getElementById ("canvas").getContext ("2d"));
      debugDraw.SetDrawScale(30);     //define scale
      debugDraw.SetAlpha(1);
      debugDraw.SetFillAlpha(.3);    //define transparency
      debugDraw.SetLineThickness(1.0);
      debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
      world.SetDebugDraw(debugDraw);

      // window.setInterval(update,1000/60);


      //mouse

      var mouseX, mouseY, mousePVec, isMouseDown, selectedBody, mouseJoint;
      var canvasPosition = getElementPosition(document.getElementById("canvas"));

      document.addEventListener("mousedown", function(e) {
          isMouseDown = true;
          handleMouseMove(e);
          document.addEventListener("mousemove", handleMouseMove, true);
      }, true);

      document.addEventListener("mouseup", function() {
          document.removeEventListener("mousemove", handleMouseMove, true);
          isMouseDown = false;
          mouseX = undefined;
          mouseY = undefined;
      }, true);

      function handleMouseMove(e) {
          mouseX = (e.clientX - canvasPosition.x) / 30;
          mouseY = (e.clientY - canvasPosition.y) / 30;
      };

      function getBodyAtMouse() {
          mousePVec = new b2Vec2(mouseX, mouseY);
          var aabb = new b2AABB();
          aabb.lowerBound.Set(mouseX - 0.001, mouseY - 0.001);
          aabb.upperBound.Set(mouseX + 0.001, mouseY + 0.001);

          // Query the world for overlapping shapes.

          selectedBody = null;
          world.QueryAABB(getBodyCB, aabb);
          return selectedBody;
      }

      function getBodyCB(fixture) {
          if(fixture.GetBody().GetType() != b2Body.b2_staticBody) {
            if(fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
                selectedBody = fixture.GetBody();
                return false;
            }
          }
          return true;
      }


      //at global scope
      var currentRayAngle = 0;

      var rayOneList = new Array();// 单一射线路径
      var rayAllList = new Array();// 全局射线路径
      /**
       * @description: 存储射线路径坐标序列
       * @param {type} 
       * @return: 
       */
      function ListUpdate(fre) {

        if(isMouseDown && (!mouseJoint)) {
                    var body = getBodyAtMouse();
                    if(body) {
                        var md = new b2MouseJointDef();
                        md.bodyA = world.GetGroundBody();
                        md.bodyB = body;
                        md.target.Set(mouseX, mouseY);
                        md.collideConnected = true;
                        md.maxForce = 300.0 * body.GetMass();
                        mouseJoint = world.CreateJoint(md);
                        body.SetAwake(true);
                    }
                  }

        if(mouseJoint) {
          if(isMouseDown) {
              mouseJoint.SetTarget(new b2Vec2(mouseX, mouseY));
          } else {
              world.DestroyJoint(mouseJoint);
              mouseJoint = null;
          }
        }

        // world.Step(1 / 60, 10, 10);
        world.DrawDebugData();
        world.ClearForces();
        world.SetContactListener(listener);

        function drawRayMain() {
          //in Step() function
          // var k = 360/20;
          // var t = k/60;
          // var DEGTORAD = Math.PI/180;
          // currentRayAngle += t * DEGTORAD; //one revolution every 20 seconds
          //console.log(currentRayAngle*(180/Math.PI));
          //at global scope
          
          var p1 = new b2Vec2(18, 8); //center of scene
          var p2 = new b2Vec2();
          // RayCastRender(p1,p2);
          var Tx = 46; // 发射功率46dBm
          var reflectionPoint = RayCastRender(Tx, p1, p2);
          // rayOneList.push(p1, reflectionPoint[0]);

          RayCastReflectRender(Math.abs(reflectionPoint[2]), reflectionPoint[0],reflectionPoint[1]);
        }
        
        // 间隔20°绘制一条射线
        // for(var i=0;i<18;i++) {
        //   currentRayAngle = i* Math.PI/9;
        //   drawRayMain();
        // }

        currentRayAngle = fre * Math.PI/9;
        drawRayMain();
        // 返回单一射线路径
        return rayOneList;


        var start = new b2Vec2(3.5,2);
        var end = new b2Vec2(8.7,9);
        console.log(rayPathRecognition.DDA_Mutation(start,end));

        
        // 自由空间电磁波功率衰减：Pr = Pt·Gr·Gt·pow(lamda/(4·π·r),2)
        // 自由空间信号强度： RSS = Pt + Gr + Gt -Lc - Lbf; Lbf = 32.5+20lgF+20lgD 发射频率和发射距离
        // 链路系统裕量: SFM = RSS - Rs；Rs为接收灵敏度
        // 虽然系统裕量大于5dB系统可以工作，但通常系统裕量大于15-20dB
          
      }

      function DrawUpdate() {
        // world.Step(1 / 60, 10, 10);
        world.DrawDebugData();
        world.ClearForces();
        world.SetContactListener(listener);

        function drawRayMain() {
          //in Step() function
          // var k = 360/20;
          // var t = k/60;
          // var DEGTORAD = Math.PI/180;
          // currentRayAngle += t * DEGTORAD; //one revolution every 20 seconds
          //console.log(currentRayAngle*(180/Math.PI));
          //at global scope
          
          var p1 = new b2Vec2(18, 8); //center of scene
          var p2 = new b2Vec2();
          // RayCastRender(p1,p2);
          var Tx = 46; // 发射功率46dBm
          var reflectionPoint = RayCastRender(Tx, p1, p2);
          // rayOneList.push(p1, reflectionPoint[0]);

          RayCastReflectRender(Math.abs(reflectionPoint[2]), reflectionPoint[0],reflectionPoint[1]);
        }

        // 间隔20°绘制一条射线
        for(var i=0;i<18;i++) {
          currentRayAngle = i* Math.PI/9;
          drawRayMain();
        }
        // currentRayAngle = 1* Math.PI/9;
        // drawRayMain();
        
        // DDA test
        var a = new b2Vec2(6.9,9.6);
        var b = new b2Vec2(0,13.61);
        // console.log(rayPathRecognition.DDA(b, a));
          
      }

      // 场强计算，不考虑穿透损耗
      var fieldStrength = {
        // 直射场，路径损耗
        perpendicular: function(Tx, d) {
          // apply COST231-Hata caculate power loss
          var fre = 2400; // emission frequency
          var ht = 45; // base station height
          var hr = 1.7; //use floor height
          var α = 3.2*Math.pow(Math.log10(11.754*hr), 2)-4.97 //bigcity && f≥300MHz
          var k = 3; //3 bigcity; 0 middle or small city；-12.25 suburban
          // var d; //distance bettwen T&R
          var L; //路径损耗
          var Gt = 11;// 天线增益，全向型天线一般为11dBi
          var Gr = 11;// 接收增益，手机天线接收收益一般为11dBi
          var Rx;// 边缘场强,0-140
          var Rs = -105;// 接收灵敏度，普通-85dBm，一般-105dBm，专业-120dBm

          L = 46.3+33.9*Math.log10(fre)-13.82*Math.log10(ht)+(44.9-6.55*Math.log10(ht))*Math.log10(d/1000)-α+k;
          Rx = Tx-L-30-20;//建筑外立面损耗30dB，链路裕量20dB

          return Rx;
        },
        // 反射场
        reflect: function(Ei, n, r) {
          var ε = 5;// 介电常数
          var nv = n.x*r.y-n.y*r.x;// 垂直单位法向矢量
          var nh = r.x*n.y-r.y*n.x;// 水平单位法向矢量
          var Ev;// 垂直极化电场
          var Eh;// 水平极化电场
          var E;// 反射电场
          // 求入射角
          var patternAB = Math.abs(r.x * n.x + r.y * n.y);
          var patternA = Math.sqrt(Math.pow(r.x, 2)+Math.pow(r.y, 2));
          var patternB = Math.sqrt(Math.pow(n.x, 2)+Math.pow(n.y, 2));
          var θ = Math.PI/2 - Math.acos(patternAB / (patternA * patternB));

          Ev = ((Ei*nv)*nv)*(Math.cos(θ)-Math.sqrt(ε-1+Math.pow(Math.cos(θ),2)))/(Math.cos(θ)+Math.sqrt(ε-1+Math.pow(Math.cos(θ),2)));
          Eh = ((Ei*nh)*nh)*(ε*Math.cos(θ)-Math.sqrt(ε-1+Math.pow(Math.cos(θ),2)))/(ε*Math.cos(θ)+Math.sqrt(ε-1+Math.pow(Math.cos(θ),2)));
          E = Ev + Eh;
          return E.toFixed(2);
        },
        // 绕射场
        diffraction: function() {
          
        },
        // 格网场强
        grid: function() {
            for(var i=0;i<38;++i){
            for(var j=0;j<16;++j){

            }
          }
        }
      }


      /**
       * @description: 求解首次碰撞点及反射点，并将其作为反射循环的输入参数
       * @param {type} 
       * @return: 
       */
      function RayCastRender(Tx, p1, p2)  {
        // //at global scope
        // var currentRayAngle = Math.PI / 3 * 4;
        var input = new b2RayCastInput();
        var output = new b2RayCastOutput();

        var intersectionPoint = new b2Vec2();// 碰撞点
        var normalEnd = new b2Vec2(); 

        var rayLength = 200; //The input power 46dbm, which equals to 40W,发射功率

        //in Step() function
        // var k = 360/20;
        // var t = k/120;
        // var DEGTORAD = Math.PI/180;
        // currentRayAngle += t * DEGTORAD; //one revolution every 20 seconds
        //console.log(currentRayAngle*(180/Math.PI));
        
        //calculate points of ray
        p2.x = p1.x + rayLength * Math.sin(currentRayAngle);
        p2.y = p1.y + rayLength * Math.cos(currentRayAngle);

        //set up input
        input.p1 = p1;
        input.p2 = p2;
        input.maxFraction = 1;
        var closestFraction = 1;
        var intersectionNormal = new b2Vec2(0,0);// 碰撞点处平面法向量

        //check every fixture of every body to find closest
        var b = new b2BodyDef();
        var f = new b2FixtureDef();
        for(b = world.GetBodyList(); b; b = b.GetNext())    {           
          for(f = b.GetFixtureList(); f; f = f.GetNext()) {
            if(!f.RayCast(output, input))
                continue;
            else if(output.fraction < closestFraction)  {
                closestFraction = output.fraction;
                intersectionNormal = output.normal;
                output = new b2RayCastOutput();
                // console.log(b);
            }
          }
        }
        
        intersectionPoint.x = p1.x + closestFraction * (p2.x - p1.x);
        intersectionPoint.y = p1.y + closestFraction * (p2.y - p1.y);

        normalEnd.x = intersectionPoint.x + intersectionNormal.x;
        normalEnd.y = intersectionPoint.y + intersectionNormal.y;

        // 求入射线和法线夹角
        // var patternAB = Math.abs(closestFraction * (p2.x - p1.x) * intersectionNormal.x + closestFraction * (p2.y - p1.y) * intersectionNormal.y);
        // var patternA = Math.sqrt(Math.pow(closestFraction * (p2.x - p1.x), 2)+Math.pow(closestFraction * (p2.y - p1.y), 2));
        // var patternB = Math.sqrt(Math.pow(intersectionNormal.x, 2)+Math.pow(intersectionNormal.y, 2));
        // // angle = Math.acos(patternAB / (patternA * patternB))  * (180 /Math.PI);
        // angle = Math.acos(patternAB / (patternA * patternB));

        // context.strokeStyle = "rgb(255, 0, 0)";
        // context.strokeStyle = "#FF6347";
        applyGrid(gridFieldLength, p1, intersectionPoint, Tx);
        d = Math.sqrt(Math.pow(intersectionPoint.x - p1.x, 2) + Math.pow(intersectionPoint.y - p1.y, 2));
        Rx = fieldStrength.perpendicular(Tx, d);
        // console.log("当前位置能量为"+Rx);


        var linearGradient = context.createLinearGradient(p1.x*30,p1.y*30,intersectionPoint.x*30,intersectionPoint.y*30);	
        linearGradient.addColorStop(0,"red");
        linearGradient.addColorStop(0.5,"orange");
        linearGradient.addColorStop(0.8,"yellow");
        linearGradient.addColorStop(1,"green");

        context.strokeStyle = linearGradient;

        // 绘制入射线c
        context.beginPath(); // Start the path
        context.moveTo(p1.x*30,p1.y*30); // Set the path origin
        context.lineTo(intersectionPoint.x*30, intersectionPoint.y*30); // Set the path destination
        context.closePath(); // Close the path
        context.stroke();



        // lineDef = new b2BodyDef;
        // lineDef.type = b2Body.b2_staticBody;
        // lineDef.position.Set(0,0.25);

        // lineFixDef = new b2FixtureDef;
        // lineFixDef.shape = new b2PolygonShape;
        // lineFixDef.shape.SetAsEdge(p1, intersectionPoint);
        
        // world.CreateBody(lineDef).CreateFixture(lineFixDef);
        

        // 绘制法线
        // context.beginPath(); // Start the path
        // context.moveTo(intersectionPoint.x*30, intersectionPoint.y*30); // Set the path origin
        // context.lineTo(normalEnd.x*30, normalEnd.y*30); // Set the path destination
        // context.closePath(); // Close the path
        // context.stroke(); // Outline the path

        if(closestFraction == 1 ) {
          return; //ray hit nothing so we can finish here
        }
        else if(closestFraction == 0 ) {
          return;
        }

        var remainingRay = new b2Vec2();
        var projectedOntoNormal = new b2Vec2();
        var nextp2 = new b2Vec2();

        remainingRay.x = (p2.x - intersectionPoint.x);
        remainingRay.y = (p2.y - intersectionPoint.y);

        // projectedOntoNormal = b2Dot(remainingRay, intersectionNormal) * intersectionNormal;
        // 求取向量点积
        var dot =  remainingRay.x * intersectionNormal.x + remainingRay.y * intersectionNormal.y;
        projectedOntoNormal.x = dot * intersectionNormal.x;
        projectedOntoNormal.y = dot * intersectionNormal.y;

        nextp2.x = p2.x - 2 * projectedOntoNormal.x;
        nextp2.y = p2.y - 2 * projectedOntoNormal.y;

        rayOneList.push(p1, intersectionPoint);
        return [intersectionPoint, nextp2, Rx];
        // RayCastRender(intersectionPoint, nextp2);

        // lineFixDef.shape.SetAsEdge(intersectionPoint, nextp2);
        // world.CreateBody(lineDef).CreateFixture(lineFixDef);

        // 与C++中采用GL库绘图不一致，canvas回归调用，并未直接生成，所以选择返回坐标
        // RayCastRender(intersectionPoint, nextp2);

        // 绘制反射线
        // context.beginPath(); // Start the path
        // context.moveTo(intersectionPoint.x*30, intersectionPoint.y*30); // Set the path origin
        // context.lineTo(nextp2.x*30, nextp2.y*30); // Set the path destination
        // context.closePath(); // Close the path
        // context.stroke(); // Outline the path  
                
      }

      /**
       * @description: 生成反射线
       * @param {type} 
       * @return: 
       */
      function RayCastReflectRender(Tx, p1, p2)  {
        //at global scope
        var input = new b2RayCastInput();
        var output = new b2RayCastOutput();

        // var rayLength = 20; //long enough to hit the walls
        var intersectionPoint = new b2Vec2();// 碰撞点
        var normalEnd = new b2Vec2(); 
        

        //set up input
        input.p1 = p1;
        input.p2 = p2;
        input.maxFraction = 1;
        var closestFraction = 1;
        var intersectionNormal = new b2Vec2(0,0);// 碰撞点处平面法向量

        //check every fixture of every body to find closest
        var b = new b2BodyDef();
        var f = new b2FixtureDef();
        for(b = world.GetBodyList(); b; b = b.GetNext())    {           
          for(f = b.GetFixtureList(); f; f = f.GetNext()) {
            if(!f.RayCast(output, input))
                continue;
            else if(output.fraction < closestFraction)  {
                closestFraction = output.fraction;
                intersectionNormal = output.normal;
                output = new b2RayCastOutput();// 清空RayCastOutPut对象，循环初始化
            }
          }
        }

        intersectionPoint.x = p1.x + closestFraction * (p2.x - p1.x);
        intersectionPoint.y = p1.y + closestFraction * (p2.y - p1.y);

        normalEnd.x = intersectionPoint.x + intersectionNormal.x;
        normalEnd.y = intersectionPoint.y + intersectionNormal.y;

        context.strokeStyle = "rgb(255, 255, 255)";

        
        // 绘制入射线
        context.beginPath(); // Start the path
        context.moveTo(p1.x*30,p1.y*30); // Set the path origin
        context.lineTo(intersectionPoint.x*30, intersectionPoint.y*30); // Set the path destination
        context.closePath(); // Close the path
        context.stroke();


        if(closestFraction == 1 ) {
          applyGrid(gridFieldLength, p1, p2, Tx);
          return; //ray hit nothing so we can finish here
        }
        else if(closestFraction == 0 ) {
          return;
        }

        var remainingRay = new b2Vec2();
        var projectedOntoNormal = new b2Vec2();
        var nextp2 = new b2Vec2();

        // still some ray left to reflect
        remainingRay.x = (p2.x - intersectionPoint.x);
        remainingRay.y = (p2.y - intersectionPoint.y);

        // 求取向量点积，点积的结果与两向量直接的角度相关
        var dot =  remainingRay.x * intersectionNormal.x + remainingRay.y * intersectionNormal.y;
        projectedOntoNormal.x = dot * intersectionNormal.x;
        projectedOntoNormal.y = dot * intersectionNormal.y;
        applyGrid(gridFieldLength, p1, intersectionPoint, Tx);

        nextp2.x = p2.x - 2 * projectedOntoNormal.x;
        nextp2.y = p2.y - 2 * projectedOntoNormal.y;

        d = Math.sqrt(Math.pow(intersectionPoint.x - p1.x, 2) + Math.pow(intersectionPoint.y - p1.y, 2));
        Rx = fieldStrength.perpendicular(Tx, d);
        rayOneList.push(intersectionPoint);

        if(Rx>-78){
          // callback
          // 注意：递归调用结束时刻位置以预定的射线总长度来表示，并未考虑传播过程中的衰减
          RayCastReflectRender(Math.abs(Rx), intersectionPoint, nextp2);
        }

        // RayCastReflectRender(Math.abs(Rx), intersectionPoint, nextp2);

        
        return [intersectionPoint, nextp2, Rx];   
        
      }

      function dataIntegrate() {
        // 路径列表更新
        for (var k=0;k<=18;k++) {
          rayAllList.push(ListUpdate(k));
          rayOneList = new Array();//清空单一路径数组，避免重复追加
        }
        console.log(rayAllList);
        
        var gridOneList = new Array();
        var gridAllList = new Array();
        var singleList;
        // var zdID =  new b2Vec2();
        // 将路径点转换为格网行列序号
        for (var m=0; m<rayAllList.length; m++) {
          for (var n=0; n<rayAllList[m].length-1; n++) {
            singleList = rayPathRecognition.DDA_Mutation(rayAllList[m][n], rayAllList[m][n+1]);
            // 存入起点和中间点
            gridOneList.push(singleList);
            // 存入终点
            // var maxN = rayAllList[m].length;
            // zdID.x = Math.ceil(rayAllList[m][maxN].x);
            // zdID.y = Math.ceil(rayAllList[m][maxN].y);
            // gridOneList.push(zdID);      
          }
          gridAllList.push(gridOneList);
          gridOneList = new Array();
        }
        console.log(gridAllList);

        // convert gridAllList to echart indeed.
        var echartData = new Array();

        for (var m=0;m<gridAllList.length;m++) {

          for (var n=0;n<gridAllList[m].length;n++) {

            for (var k=0;k<gridAllList[m][n].length;k++){
              echartData.push([gridAllList[m][n][k].x, gridAllList[m][n][k].y]);
            }
          }
        }

        console.log(echartData);
        return echartData;
      }

      // 频次计算
      // var countData = echartData.reduce(function(echartData, data) {
      //   var arr = [];
      //   if(data in echartData) {
      //     echartData[data]++;
      //   }
      //   else{
      //     echartData[data] =1;
      //   }
      //   for(var e in echartData){
      //     arr.push([e, echartData[e]]);
      //   }
      //   return arr;
      // }, []);
      // console.log(countData);

      //方法：使用obj记录重复的元素，以及出现的次数
      function getCount(arr) {
          var obj = {},
              k, arr1 = [];
              arr2 = [];
          var pre, cur;
          for(var i = 0; i < arr.length; i++) {
              k = arr[i];
              if(obj[k])
                  obj[k]++;
              else
                  obj[k] = 1;
          }
          // console.log(obj);
          //保存结果{el-'元素'，count-出现次数}
          // for(var o in obj) {
          //     arr1.push({
          //         el: o,
          //         count: obj[o]
          //     });
          // }
   
          for (var o in obj) {
            var arr = o.split(",");
            var x = parseInt(arr[0]);
            var y = parseInt(arr[1]);
            arr1.push([x, y, gridFieldLength.get(x, y)]);
          }
          console.log(gridFieldLength.get(19, 15));
          return arr1;
      }



      /**
       * @description: 绘制最终网格热力图
       * @param {type} 
       * @return: 
       */
      function drawHeatCartesian() {
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('main'));

        // 指定图表的配置项和数据
        var X = ['1', '2', '3', '4', '5', '6', '7',
        '8', '9', '10','11','12', '13', '14', '15',
        '16', '17', '18', '19', '20', '21', '22', '23',
        '24', '25', '26', '27', '28', '29', '30', '31', 
        '32', '33', '34', '35', '36', '37', '38'];

        var Y = ['1', '2', '3', '4', '5', '6', '7',
        '8', '9', '10','11','12', '13', '14', '15',
        '16'];
        var data = getCount(dataIntegrate());

        var data = data.map(function (item) {
            return [item[0], item[1], item[2] || '-'];
        }); 

        var option = {
            tooltip: {
              position: 'top',
              formatter: function(params){
                var seriesName = params.seriesName;
                var value = params.value;
                return ('边缘场强：' + value[2] + '<br/>' + '坐标：'+ value[0]+', '+ value[1]+'<br/>');
              }
            },
            toolbox: {
                show : false,
                feature : {
                    mark : {show: true},
                    dataZoom : {show: true},
                    dataView : {show: true, readOnly: false},
                    restore : {show: true},
                    saveAsImage : {show: true}
                }
            },
            animation: false,
            grid: {
                height: '100%',//grid 组件高度
                width: '100%',//grid 组件宽度
                left: '0%',//grid 组件离容器左侧的距离
                top: '0%'//grid 组件离容器上侧的距离
            },
            xAxis: {
                position: 'top',
                type: 'category',
                data: X,
                axisLine: {
                  onZero: false
                },
                splitArea: {
                    show: true
                }
            },
            yAxis: {
                inverse: true,
                type: 'category',
                data: Y,
                axisLine: {
                  onZero: false
                },
                splitArea: {
                    show: true
                }
            },
            visualMap: {
                // type: 'piecewise',// 设置视觉映射组件的类型：连续和分段
                // splitNumber:4,// 分段型视觉映射组件中的连续型数据，会自动平均切分成几段
                show: false,
                min: -78,
                max: 0,
                inRange:{
                  color: ['#EE5C42', '#836FFF', '#98FB98'].reverse()
                },// 定义在选中范围中的视觉元素
                outRange:{
                  color: '#828282'
                },
                  textStyle: {
                  color: '#fff'
                },
                calculable: true,
                orient: 'horizontal',
                left: 'center',
                bottom: '15%'
            },
            series: [{
                name: '边缘场强',
                type: 'heatmap',
                data: data,
                label: {
                  show: true,
                  textStyle: {
                    fontWeight: 'normal', 
                    color: '#E8E8E8'
                  },
                },
                emphasis: {
                    itemStyle: {
                        shadowBlur: 10,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }]
        };
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
        // 获取离屏canvas
        var offcanvas = myChart.getRenderedCanvas({
          pixelRatio: 2,
          backgroundColor: '#F5F5F5'
        });
        return offcanvas;
      };
      offcanvas = drawHeatCartesian();
      // 绘图更新，受box2d绘图机制影响，路径列表更新与绘图更新需要分别进行
      DrawUpdate();
      context.globalAlpha = 0.45;
      context.drawImage(offcanvas,0,0,1140,480);
      
      // draw1(gridFieldLength);
      


      //http://js-tut.aardon.de/js-tut/tutorial/position.html
      function getElementPosition(element) {
        var elem=element, tagname="", x=0, y=0;

        while((typeof(elem) == "object") && (typeof(elem.tagName) != "undefined")) {
            y += elem.offsetTop;
            x += elem.offsetLeft;
            tagname = elem.tagName.toUpperCase();

            if(tagname == "BODY")
              elem=0;

            if(typeof(elem) == "object") {
              if(typeof(elem.offsetParent) == "object")
                  elem = elem.offsetParent;
            }
        }

        return {x: x, y: y};
      }


      function bodyCoordGet() {
        // 屏幕经纬度
        var scminp=new whpoint(0, 0);
        var scmaxp=new whpoint(10, 14);
        var screct=new whrect(scminp,scmaxp);

        // 地图投影
        var mminp=new whpoint(11586917.36191,3589973.11670);
        var mmaxp=new whpoint(11586993.22675,3590041.88709);    
        var mrect=new whrect(mminp,mmaxp);

        // 转换映射
        var mycoordchange=new whcoordchange(screct,mrect);
        var mapoint1=new whpoint(11586956.38138,3590060.13813);
        var mapoint2=new whpoint(11586956.38138,3590055.56107);
        var mapoint3=new whpoint(11586973.54537,3590048.58105);

        var scmapoint1=mycoordchange.maptoscreen(mapoint1);
        var scmapoint2=mycoordchange.maptoscreen(mapoint2);
        var scmapoint3=mycoordchange.maptoscreen(mapoint3);

        console.log(scmapoint1, scmapoint2, scmapoint3);

        // var list = new List();
        // list.append(scmapoint1, scmapoint2, scmapoint3);
        // console.log(list);

        // 3.000692, 0.289297    3.000692, 0.293138    3.012279, 0.298885

        // return list;

        
      }

      function draw1(gridFieldLength) {
      var pointsdata = gridFieldLength.heatMap();
      // var canvas = document.getElementById('canvas');
      // if (canvas.getContext) {
      //     var context = canvas.getContext("2d");
      // } else {
      //     alert('浏览器不支持canvas!');
      // }
      // context.clearRect(0, 0, 1200, 500);
      /*
        * radius: 绘制半径，请自行设置
        * min, max: 强弱阈值，可自行设置，也可取数据最小最大值
        */
      var radius = 50;
      let [min, max] = gridFieldLength.threshold();
      min = min - 50;
      pointsdata.forEach(point => {
          let {
              x,
              y,
              value
          } = point;
          x = x * 30;
          y = y * 30;
          context.beginPath();
          context.arc(x, y, radius, 0, 2 * Math.PI);
          context.closePath();

          // 创建渐变色: r,g,b取值比较自由，我们只关注alpha的数值
          let radialGradient = context.createRadialGradient(x, y, 0, x, y, radius);
          radialGradient.addColorStop(0.0, "rgba(0,0,0,1)");
          radialGradient.addColorStop(1.0, "rgba(0,0,0,0)");
          context.fillStyle = radialGradient;
          
          // 设置globalAlpha: 需注意取值需规范在0-1之间
          let globalAlpha = (value - min) / (max - min);
          context.globalAlpha = Math.max(Math.min(globalAlpha, 1), 0);

          // 填充颜色
          context.fill();
      });
      // const defaultColorStops = {
      //     0: "#f00",
      //     0.2: "#0f0",
      //     0.4: "#00f",
      //     1: "#0ff",
      // };
      const defaultColorStops = {
        '0.2': 'rgba(0, 0, 255, 0.2)',
        '0.3': 'rgba(43, 111, 231, 0.3)',
        '0.4': 'rgba(2, 192, 241, 0.4)',
        '0.6': 'rgba(44, 222, 148, 0.6)',
        '0.8': 'rgba(254, 237, 83, 0.8)',
        '0.9': 'rgba(255, 118, 50, 0.9)',
        '1.0': 'rgba(255, 0, 0, 1)'
      };
      const width = 500,
          height = 1200;

      function Palette(opts) {
          Object.assign(this, opts);
          this.init();
      }

      Palette.prototype.init = function() {
          let colorStops = this.colorStops || defaultColorStops;

          // 创建canvas
          let canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          let ctx = canvas.getContext("2d");

          // 创建线性渐变色
          let linearGradient = ctx.createLinearGradient(0, 0, 0, 256);
          for (const key in colorStops) {
              linearGradient.addColorStop(key, colorStops[key]);
          }

          // 绘制渐变色条
          ctx.fillStyle = linearGradient;
          ctx.fillRect(0, 0, 20, 256);

          // 读取像素数据
          this.imageData = ctx.getImageData(0, 0, 1, 256).data;
          this.canvas = canvas;
      };

      /**
       * 取色器
       * @param {Number} position 像素位置
       * @return {Array.<Number>} [r, g, b]
       */
      Palette.prototype.colorPicker = function(position) {
          return this.imageData.slice(position * 4, position * 4 + 3);
      };
      // 像素着色
      let imageData = context.getImageData(0, 0, 1200, 500);
      let data = imageData.data;
      // console.log(imageData);
      let palette = new Palette(this.context);
      for (var i = 3; i < data.length; i += 4) {
          let alpha = data[i];
          let color = palette.colorPicker(alpha);
          data[i - 3] = color[0];
          data[i - 2] = color[1];
          data[i - 1] = color[2];
      };
      context.putImageData(imageData, 0, 0);
      }
    }

    // 路径识别
    var rayPathRecognition = {
        /**
         * @description: 数组去重
         * @param {type} 
         * @return: 
         */
        unique: function(arr) {
          if (!Array.isArray(arr)) {
            console.log('type error!')
            return
          };
          // 方法一：比较法，缺点：效率太低
          // for(var i=0;i<arr.length-1;i++){
          //   for(var j=1;j<arr.length;j++){
          //     while(i!=j){
          //       if(arr[i].x == arr[j].x && arr[i].y == arr[j].y){
          //         arr.splice(j,1);
          //       }
          //     }
          //   }
          // }

          // 方法二：降维法
          const obj ={};
          for(const item of arr){
            obj[item.x+','+item.y] = item;
          }
          arr = Object.values(obj);
          return arr;
        },
        /**
         * @description: 数值微分算法求解网格路径
         * @param {type} 
         * @return: 
         */        
        DDA: function(startPoint, endPoint) {
          var dx = Math.abs(startPoint.x-endPoint.x);
          var dy = Math.abs(startPoint.y-endPoint.y);
          var steps = Math.max(dx,dy);
          // 临时存入点列表与网格单元列表不一致
          var temList = new Array();
          var gridList = new Array();
          // 设置增量
          var increX = (endPoint.x-startPoint.x)/steps;
          var increY = (endPoint.y-startPoint.y)/steps;
          // 注意：路径保存需要保留起始坐标
          for (var i = 0; i<=steps; i++){
            // 直线方向交点
            var temPoint = new b2Vec2();
            temPoint.x = startPoint.x + increX * i;
            temPoint.y = startPoint.y + increY * i;
            temList.push(temPoint);
          }
          // console.log(temList);

          /*
           * 截止此处，已将直线与网格单元边界线的交点求出，接下来需要获取对应的网格序列号（依旧用坐标表示）  
          */
          // 网格路径单元，起始点单独计算
          var startId = new b2Vec2();
          var endId = new b2Vec2();
          startId.x = Math.ceil(startPoint.x);
          startId.y = Math.ceil(startPoint.y);

          endId.x = Math.ceil(endPoint.x);
          endId.y = Math.ceil(endPoint.y);
          // 将起点网格ID放入路径
          gridList.push(startId);

          // 将除起始点外其他点导入
          for (var j=1; j<(temList.length);j++) {
            var temGridId1 = new b2Vec2();
            var temGridId2 = new b2Vec2();
            if((temList[j].x !=Math.ceil(temList[j].x)) && 
            (temList[j].y ==Math.ceil(temList[j].y))){
              temGridId1.x = Math.ceil(temList[j].x);
              temGridId1.y = Math.ceil(temList[j].y)-1;
              temGridId2.x = Math.ceil(temList[j].x);
              temGridId2.y = Math.ceil(temList[j].y);
              gridList.push(temGridId1, temGridId2);
            } 
            else if((temList[j].y !=Math.ceil(temList[j].y)) && 
            (temList[j].x ==Math.ceil(temList[j].x))) {
              temGridId1.x = Math.ceil(temList[j].x)-1;
              temGridId1.y = Math.ceil(temList[j].y);
              temGridId2.x = Math.ceil(temList[j].x);
              temGridId2.y = Math.ceil(temList[j].y);
              gridList.push(temGridId1, temGridId2);
            }
            else if((temList[j].x ==Math.ceil(temList[j].x)) && 
            (temList[j].y ==Math.ceil(temList[j].y))){
              temGridId1.x = Math.ceil(temList[j].x);
              temGridId1.y = Math.ceil(temList[j].y);
              gridList.push(temGridId1);
            }
            else {
              temGridId1.x = Math.ceil(temList[j].x);
              temGridId1.y = Math.ceil(temList[j].y);
              gridList.push(temGridId1);
            }
          };

          // 将终点网格ID放入路径
          gridList.push(endId);
      
          // return temList;
          return rayPathRecognition.unique(gridList);
        },
        /**
         * @description: 计算线段与网格线的交点，进而判断线段经过网格的序号
         * @param {type} 
         * @return: 
         */
        DDA_Mutation: function(startPoint, endPoint){
          var dx = endPoint.x - startPoint.x;
          var dy = endPoint.y - startPoint.y;
          // 临时存入点列表与网格单元列表不一致
          var temList = new Array();
          var gridList = new Array();
          // 设置增量
          var increX = dx/Math.abs(dx);
          var increY = dy/Math.abs(dy);

          // 直线方程：斜截式
          var k = dy/dx;
          var b = -k * startPoint.x + startPoint.y;

          // 注意：路径保存需要保留起始坐标
          for (var m=0; m<=Math.abs(dx); m++) {
            // 沿横轴方向遍历，既查询与网格纵轴的交点
            var temPoint1 = new b2Vec2();
            // if(increX > 0){
            //   temPoint1.x = Math.floor(startPoint.x) + increX * m;
            //   temPoint1.y = k * temPoint1.x + b;
            //   temList.push(temPoint1);
            // }else {
            //   temPoint1.x = Math.ceil(startPoint.x) + increX * m;
            //   temPoint1.y = k * temPoint1.x + b;
            //   temList.push(temPoint1);
            // }
            temPoint1.x = Math.ceil(startPoint.x) + increX * m;
            temPoint1.y = k * temPoint1.x + b;
            temList.push(temPoint1); 
          }
          // 沿纵轴方向遍历，既查询与网格横轴的交点
          for (var n=0; n<=Math.abs(dy); n++) {
            var temPoint2 = new b2Vec2();
            // if(increY > 0) {
            //   temPoint2.y = Math.floor(startPoint.y) + increY * n;
            //   temPoint2.x = (temPoint2.y - startPoint.y) / k + startPoint.x;
            //   temList.push(temPoint2);
            // }else {
            //   temPoint2.y = Math.ceil(startPoint.y) + increY * n;
            //   temPoint2.x = (temPoint2.y - startPoint.y) / k + startPoint.x;
            //   temList.push(temPoint2);
            // }
            temPoint2.y = Math.ceil(startPoint.y) + increY * n;
            temPoint2.x = (temPoint2.y - startPoint.y) / k + startPoint.x;
            temList.push(temPoint2);
          }

          // console.log(temList);

          /*
           * 截止此处，已将直线与网格单元边界线的交点求出，接下来需要获取对应的网格序列号（依旧用坐标表示）  
          */
          // 网格路径单元，起始点单独计算
          var startId = new b2Vec2();
          var endId = new b2Vec2();
          startId.x = Math.ceil(startPoint.x);
          startId.y = Math.ceil(startPoint.y);

          endId.x = Math.ceil(endPoint.x);
          endId.y = Math.ceil(endPoint.y);
          // 将起点网格ID放入路径
          // gridList.push(startId);

          // 将除起始点外其他点导入,应用echart时包括0行0列
          for (var j=0; j<(temList.length);j++) {
            var temGridId1 = new b2Vec2();
            var temGridId2 = new b2Vec2();
            var temGridId3 = new b2Vec2();
            var temGridId4 = new b2Vec2();
            if((temList[j].x !=Math.ceil(temList[j].x)) && 
            (temList[j].y ==Math.ceil(temList[j].y))){
              temGridId1.x = Math.ceil(temList[j].x)-1;
              temGridId1.y = Math.ceil(temList[j].y)-1+1;
              temGridId2.x = Math.ceil(temList[j].x)-1;
              temGridId2.y = Math.ceil(temList[j].y)-1;
              gridList.push(temGridId1, temGridId2);
            } 
            else if((temList[j].y !=Math.ceil(temList[j].y)) && 
            (temList[j].x ==Math.ceil(temList[j].x))) {
              temGridId1.x = Math.ceil(temList[j].x)-1;
              temGridId1.y = Math.ceil(temList[j].y)-1;
              temGridId2.x = Math.ceil(temList[j].x)-1+1;
              temGridId2.y = Math.ceil(temList[j].y)-1;
              gridList.push(temGridId1, temGridId2);
            }
            else{
              temGridId1.x = Math.ceil(temList[j].x)-1;
              temGridId1.y = Math.ceil(temList[j].y)-1;
              temGridId2.x = Math.ceil(temList[j].x)-1+1;
              temGridId2.y = Math.ceil(temList[j].y)-1;
              temGridId3.x = Math.ceil(temList[j].x)-1;
              temGridId3.y = Math.ceil(temList[j].y)-1+1;
              temGridId4.x = Math.ceil(temList[j].x)-1+1;
              temGridId4.y = Math.ceil(temList[j].y)-1+1;
              gridList.push(temGridId1,temGridId2,temGridId3,temGridId4);
            }
          };

          // 将终点网格ID放入路径
          // gridList.push(endId);
          return rayPathRecognition.unique(gridList);
          // return gridList;
        }
      }
  </script>
</html>